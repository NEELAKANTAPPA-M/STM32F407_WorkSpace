/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include<stdint.h>
#include<stdio.h>
#include <main.h>
#include <type.h>
#include <led.h>
#include <task.h>

u8 current_task = 1; // task1 is running
u32 g_tick_cnt = 0;
TCB_st user_task[MAX_TASKS];

int main(void)
{
	enable_fault_handlers();
	init_scheduler_stack(SCHED_STACK_START);
	init_tasks_stack();
	led_init_all();
	init_systick_timer(TICK_HZ);
	switch_sp_to_psp();
	t1_handler();
	for(;;);
}

__attribute__((naked)) void switch_sp_to_psp(void)
{
	// get the psp of current task & store it to PSP register
	__asm__ volatile("PUSH {LR}"); // preserve LR which connects back to main()
	__asm__ volatile("BL get_psp_value");
	__asm__ volatile("MSR PSP, R0"); // store psp value from r0 to PSP register
	__asm__ volatile("POP {LR}"); // store back LR from stack

	//change sp to psp using CONTROL register
	__asm__ volatile("MOV R0,#0x02"); //
	__asm__ volatile("MSR CONTROL, R0");
	__asm__ volatile("BX LR");

}

u32 get_psp_value(void)
{
	return user_task[current_task].psp_value;
}
void save_psp_value(u32 current_psp_value)
{
	user_task[current_task].psp_value = current_psp_value;
}

void idle_handler(void)
{
	while(1);
}
void t1_handler(void)
{
	while(1) {
		led_on(LED_GREEN);
		task_delay(1000);
		led_off(LED_GREEN);
		task_delay(1000);
	}
}
void t2_handler(void)
{
	while(1) {
		led_on(LED_ORANGE);
		task_delay(500);
		led_off(LED_ORANGE);
		task_delay(500);
	}
}
void t3_handler(void)
{
	while(1) {
		led_on(LED_BLUE);
		task_delay(250);
		led_off(LED_BLUE);
		task_delay(250);
	}
}
void t4_handler(void)
{
	while(1) {
		led_on(LED_RED);
		task_delay(125);
		led_off(LED_RED);
		task_delay(125);
	}
}

void init_tasks_stack()
{
	u32 i;
	u32 *pPSP;

	user_task[0].current_state = TASK_READY_STATE;
	user_task[1].current_state = TASK_READY_STATE;
	user_task[2].current_state = TASK_READY_STATE;
	user_task[3].current_state = TASK_READY_STATE;
	user_task[4].current_state = TASK_READY_STATE;

	user_task[0].psp_value = IDLE_STACK_START;
	user_task[1].psp_value = T1_STACK_START;
	user_task[2].psp_value = T2_STACK_START;
	user_task[3].psp_value = T3_STACK_START;
	user_task[4].psp_value = T4_STACK_START;

	user_task[0].task_handler = idle_handler;
	user_task[1].task_handler = t1_handler;
	user_task[2].task_handler = t2_handler;
	user_task[3].task_handler = t3_handler;
	user_task[4].task_handler = t4_handler;

	for(i = 0; i < MAX_TASKS; i++) {
		s32 j;
		pPSP =(u32 *) user_task[i].psp_value;
		pPSP--;
		*pPSP = DUMMY_XPSR; //xpsr
		pPSP--;
		*pPSP = (u32)user_task[i].task_handler; //PC
		pPSP--;
		*pPSP = 0xFFFFFFFD;//LR

		/* loop for 13 general purpose registers*/
		for(j = 0; j < 13; j++) {
			pPSP--;
			*pPSP = 0x0;
		}
		user_task[i].psp_value = (u32)pPSP;
	}
}

void init_systick_timer(u32 tick_hz)
{
	u32 *pCSR = (u32 *) SYST_CSR;
	u32 *pRVR = (u32 *) SYST_RVR;

	u32 cnt_val = (SYS_TICK_TIMER_CLK/tick_hz) - 1;

	*pRVR &= ~(0x00FFFFFF);
	*pRVR = cnt_val;

	*pCSR |= (1 << 1);
	*pCSR |= (1 << 2);

	*pCSR |= (1 << 0);
}

__attribute__((naked)) void init_scheduler_stack(u32 sched_stack_top)
{
	__asm__ volatile("MSR MSP, %0"::"r"(sched_stack_top):);
	__asm__ volatile("BX LR");
}

void enable_fault_handlers(void)
{
	// enable mem fault, usage fault,bus fault
	uint32_t *pSHCSR = (uint32_t *)SHCSR;
	*pSHCSR |= ((1<< MEMFAULTENA_POS) | (1 << BUSFAULTENA_POS)| (1 << USGFAULTENA_POS));
}

void HardFault_Handler()
{
	printf("Exception: HardFault_Handler \n");
	while(1);
}

void MemManage_Handler()
{
	printf("Exception: MemManage_Handler \n");
	while(1);
}

void BusFault_Handler()
{
	printf("Exception: BusFault_Handler \n");
	while(1);
}


void update_next_task(void)
{
	int state = TASK_BLOCK_STATE;

	for(int i= 0 ; i < (MAX_TASKS) ; i++)
	{
		current_task++;
		current_task %= MAX_TASKS;
		state = user_task[current_task].current_state;
		if ((state == TASK_READY_STATE) && (current_task != 0))
			break;
	}

	if(state != TASK_READY_STATE)
		current_task = 0;
}



__attribute__((naked)) void PendSV_Handler(void)
{
	/* save the context of current task */

	// push the value of LR to stack
	__asm volatile("PUSH {LR}");

	// get the psp value
	__asm volatile("MRS R0, PSP");;

	// store sf2 to stack
	__asm volatile("STMDB R0!, {R4-R11}");

	// save psp value to global variable
	__asm volatile("BL save_psp_value");

	/* Switch to & Retrieve the context of next task*/

	//Decide next task to run
	__asm volatile("BL update_next_task");

	//get its past psp value
	__asm volatile("BL get_psp_value");

	// load back saved register values to GPRs
	__asm volatile("LDMIA R0!, {R4-R11}");

	//update psp & Exit
	__asm volatile("MSR PSP, R0");

	// pop the value of LR to stack
	__asm volatile("POP {LR}");

	__asm volatile("BX LR");

}

void update_global_tick_cnt()
{
	g_tick_cnt++;
}

void unblock_tasks()
{
	int i;
	for (i = 1; i < MAX_TASKS; i++) {
		if (user_task[i].current_state != TASK_READY_STATE) {
			if (user_task[i].block_cnt == g_tick_cnt) {
				user_task[i].current_state = TASK_READY_STATE;
			}
		}
	}
}

__attribute__((naked)) void SysTick_Handler(void)
{
	uint32_t *pICSR = (uint32_t*)ICSR;
	update_global_tick_cnt();
	unblock_tasks();

	//pend the pendSV interrupt
	*pICSR |= ( 1 << 28);
}

void schedule()
{
	//pend the pendSV interrupt
	uint32_t *pICSR = (uint32_t*)ICSR;
	*pICSR |= ( 1 << 28);
}

void task_delay(u32 tick_count)
{
	if (current_task) {
		user_task[current_task].block_cnt = g_tick_cnt + tick_count;
		user_task[current_task].current_state = TASK_BLOCK_STATE;
		schedule();
	}
}
